<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Exclusão Mútua com RPC</title>
    <link rel="stylesheet" href="style.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
</head>
<body>
    <nav class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <h3><i class="fas fa-network-wired"></i> RPC & Exclusão Mútua</h3>
            <button class="sidebar-toggle" id="sidebarToggle">
                <i class="fas fa-times"></i>
            </button>
        </div>
        
        <ul class="sidebar-menu">
            <li><a href="#introducao" data-section="introducao"><i class="fas fa-home"></i> Introdução</a></li>
            <li><a href="#rpc-abstraction" data-section="rpc-abstraction"><i class="fas fa-cloud"></i> Abstração RPC</a></li>
            <li><a href="#desafios" data-section="desafios"><i class="fas fa-exclamation-triangle"></i> Desafios</a></li>
            <li><a href="#vantagens-desvantagens" data-section="vantagens-desvantagens"><i class="fas fa-balance-scale"></i> Prós & Contras</a></li>
            <li><a href="#demonstracao" data-section="demonstracao"><i class="fas fa-code"></i> Demonstração</a></li>
            <li><a href="#conclusao" data-section="conclusao"><i class="fas fa-check-circle"></i> Conclusão</a></li>
        </ul>
    </nav>

    <div class="sidebar-overlay" id="sidebarOverlay"></div>

    <button class="mobile-menu-btn" id="mobileMenuBtn">
        <i class="fas fa-bars"></i>
    </button>

    <main class="main-content">
        <!-- Cabeçalho -->
        <header id="introducao">
            <div class="header-content">
                <h1>Exclusão Mútua em Sistemas Distribuídos: A Solução por Passagem de Mensagens via RPC</h1>

            </div>
        </header>

        <!-- Seção: Abstração RPC -->
        <section id="rpc-abstraction" class="content-section">
            <div class="section-header">
                <h2><i class="fas fa-cloud"></i> Abstraindo a Complexidade com RPC</h2>
           
            </div>
            <div class="section-content">
                <p>A Chamada de Procedimento Remoto (RPC) é um poderoso modelo de comunicação que permite que um programa execute um procedimento em outra máquina na rede como se fosse uma chamada local. Com o RPC, o programador não precisa lidar diretamente com os detalhes de baixo nível, como serialização de dados (marshalling), sockets ou protocolos de rede.</p>
                
                <p>No contexto da exclusão mútua, essa abstração é fundamental. Cada processo no sistema distribuído assume um duplo papel: atua como um cliente quando deseja acessar uma seção crítica e como um servidor ao responder às solicitações de outros processos. A troca de mensagens necessária para algoritmos de exclusão mútua é elegantemente mapeada para chamadas de procedimentos remotos.</p>
            </div>
        </section>

        <!-- Seção: Desafios -->
        <section id="desafios" class="content-section">
            <div class="section-header">
                <h2><i class="fas fa-exclamation-triangle"></i> O Desafio da Exclusão Mútua em Ambientes Distribuídos</h2>
           
            </div>
            <div class="section-content">
                <p>Em sistemas centralizados, a exclusão mútua é resolvida com primitivas como semáforos e mutexes, que dependem de memória compartilhada e de um kernel único. Em sistemas distribuídos, essa abordagem não é viável devido a desafios inerentes:</p>
                
                <div class="challenges-grid">
                    <div class="challenge-card">
                        <div class="challenge-icon">
                            <i class="fas fa-memory"></i>
                        </div>
                        <h4>Ausência de Memória Compartilhada</h4>
                        <p>O estado global não está disponível em um único local, e cada processo possui apenas sua visão parcial do sistema.</p>
                    </div>
                    
                    <div class="challenge-card">
                        <div class="challenge-icon">
                            <i class="fas fa-clock"></i>
                        </div>
                        <h4>Ausência de um Relógio Global</h4>
                        <p>É impossível determinar a ordem exata de eventos que ocorrem em máquinas diferentes, o que complica a coordenação.</p>
                    </div>
                    
                    <div class="challenge-card">
                        <div class="challenge-icon">
                            <i class="fas fa-wifi"></i>
                        </div>
                        <h4>Latência e Falhas na Rede</h4>
                        <p>A comunicação está sujeita a atrasos imprevisíveis e à perda de mensagens, exigindo que os algoritmos sejam tolerantes a falhas.</p>
                    </div>
                </div>
            </div>
        </section>

        <section id="vantagens-desvantagens" class="content-section">
            <div class="section-header">
                <h2><i class="fas fa-balance-scale"></i> Vantagens e Desvantagens do Uso de RPC</h2>

            </div>
            <div class="section-content">
                <div class="pros-cons-container">
                    <div class="pros-section">
                        <div class="pros-header">
                            <i class="fas fa-thumbs-up"></i>
                            <h3>Vantagens</h3>
                        </div>
                        <ul class="pros-list">
                            <li>
                                <strong>Abstração e Simplicidade:</strong> O modelo de chamada de procedimento esconde a complexidade da comunicação em rede, simplificando o desenvolvimento.
                            </li>
                            <li>
                                <strong>Clareza do Código:</strong> A lógica de coordenação se assemelha a simples chamadas de função, tornando o código mais legível e fácil de manter.
                            </li>
                            <li>
                                <strong>Reutilização:</strong> Os componentes de cliente e servidor (stubs) gerados por ferramentas RPC podem ser facilmente reutilizados em diferentes partes do sistema.
                            </li>
                        </ul>
                    </div>
                    
                    <div class="cons-section">
                        <div class="cons-header">
                            <i class="fas fa-thumbs-down"></i>
                            <h3>Desvantagens</h3>
                        </div>
                        <ul class="cons-list">
                            <li>
                                <strong>Acoplamento Síncrono:</strong> Por padrão, RPCs são bloqueantes, o que significa que o cliente para até receber uma resposta. Isso pode causar ineficiência se um servidor estiver lento ou falhar. O uso de chamadas assíncronas é crucial para mitigar esse problema.
                            </li>
                            <li>
                                <strong>Overhead:</strong> A abstração do RPC pode introduzir uma sobrecarga de desempenho devido às camadas de serialização e desserialização de dados.
                            </li>
                            <li>
                                <strong>Gestão de Falhas:</strong> Lidar com a falha de um processo servidor é complexo, pois o cliente pode ficar bloqueado indefinidamente. Mecanismos como timeouts são essenciais.
                            </li>
                        </ul>
                    </div>
                </div>
            </div>
        </section>

        <section id="demonstracao" class="content-section">
            <div class="section-header">
                <h2><i class="fas fa-code"></i> Demonstração Prática</h2>
            </div>
            <div class="section-content">
                <p>A seguir, apresentamos um exemplo de algoritmo que utiliza RPC para garantir a exclusão mútua. O código demonstra como um professor (servidor) gerencia as solicitações de ajuda dos alunos (clientes).</p>
                
                <!-- Código do Servidor (Professor) -->
                <div class="code-section">
                    <div class="code-header">
                        <span class="code-title">
                            <i class="fas fa-server"></i> professor_servidor.py (Servidor)
                        </span>
                        <button class="btn btn-small copy-code" onclick="copyCode('serverCode')">
                            <i class="fas fa-copy"></i> Copiar
                        </button>
                    </div>
                    <div class="code-container">
                        <pre><code id="serverCode">import time
from xmlrpc.server import SimpleXMLRPCServer

def ajudar_aluno(aluno_id):
    print(f"[PROFESSOR]: Recebi uma solicitação de ajuda do Aluno {aluno_id}.")
    time.sleep(2)
    print(f"[PROFESSOR]: Ajudei o Aluno {aluno_id}. Enviando a resposta.")
    return f"Ajuda concluída com sucesso para o Aluno {aluno_id}."

with SimpleXMLRPCServer(("localhost", 8000)) as servidor:
    print("Servidor do Professor online e aguardando chamadas RPC...")
    servidor.register_function(ajudar_aluno, "ajudar_aluno")
    servidor.serve_forever()</code></pre>
                    </div>
                </div>

                <!-- Código do Cliente (Aluno) -->
                <div class="code-section">
                    <div class="code-header">
                        <span class="code-title">
                            <i class="fas fa-user"></i> aluno_cliente.py (Cliente)
                        </span>
                        <button class="btn btn-small copy-code" onclick="copyCode('clientCode')">
                            <i class="fas fa-copy"></i> Copiar
                        </button>
                    </div>
                    <div class="code-container">
                        <pre><code id="clientCode">import xmlrpc.client
import time

def solicitar_ajuda_aluno(aluno_id, professor):
    print(f"[ALUNO {aluno_id}]: Preciso de ajuda do professor. Fazendo chamada RPC...")

    resultado = professor.ajudar_aluno(aluno_id)
    
    print(f"[ALUNO {aluno_id}]: Recebi a resposta remota: '{resultado}'")
    print(f"[ALUNO {aluno_id}]: Tarefa finalizada.")

try:
    with xmlrpc.client.ServerProxy("http://localhost:8000/") as professor:
        solicitar_ajuda_aluno(1, professor)

        solicitar_ajuda_aluno(2, professor)

except ConnectionRefusedError:
    print("Erro: Servidor não encontrado. Verifique se 'professor_servidor.py' está rodando.")</code></pre>
                    </div>
                </div>

                <!-- Terminais de Demonstração -->
                <div class="terminals-container">
                    <!-- Terminal do Servidor -->
                    <div class="terminal-section">
                        <div class="terminal-header">
                            <span class="terminal-title">
                                <i class="fas fa-terminal"></i> Terminal - Servidor (Professor)
                            </span>
                        </div>
                        <div class="terminal-container">
                            <pre><code class="terminal-output">$ python professor_servidor.py
Servidor do Professor online e aguardando chamadas RPC...
[PROFESSOR]: Recebi uma solicitação de ajuda do Aluno 1.
[PROFESSOR]: Ajudei o Aluno 1. Enviando a resposta.
[PROFESSOR]: Recebi uma solicitação de ajuda do Aluno 2.
[PROFESSOR]: Ajudei o Aluno 2. Enviando a resposta.</code></pre>
                        </div>
                    </div>

                    <!-- Terminal do Cliente -->
                    <div class="terminal-section">
                        <div class="terminal-header">
                            <span class="terminal-title">
                                <i class="fas fa-terminal"></i> Terminal - Cliente (Alunos)
                            </span>
                        </div>
                        <div class="terminal-container">
                            <pre><code class="terminal-output">$ python aluno_cliente.py
[ALUNO 1]: Preciso de ajuda do professor. Fazendo chamada RPC...
[ALUNO 1]: Recebi a resposta remota: 'Ajuda concluída com sucesso para o Aluno 1.'
[ALUNO 1]: Tarefa finalizada.
[ALUNO 2]: Preciso de ajuda do professor. Fazendo chamada RPC...
[ALUNO 2]: Recebi a resposta remota: 'Ajuda concluída com sucesso para o Aluno 2.'
[ALUNO 2]: Tarefa finalizada.</code></pre>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <section id="conclusao" class="content-section">
            <div class="section-header">
                <h2><i class="fas fa-check-circle"></i> Conclusão</h2>
            </div>
            <div class="section-content">
                <p>O uso de RPC oferece uma solução estruturada e compreensível para o problema da exclusão mútua em sistemas distribuídos. Ao modelar algoritmos complexos, como os de Ricart-Agrawala, como serviços remotos, os desenvolvedores podem focar na lógica de coordenação em vez dos detalhes de baixo nível da comunicação. Embora a natureza síncrona do RPC exija cuidado para garantir eficiência e robustez, sua clareza e simplicidade o tornam uma ferramenta poderosa para construir sistemas distribuídos corretos e confiáveis.</p>

            </div>
        </section>

        <footer>
            <div class="footer-content">
                <p><i class="fas fa-users"></i> Desenvolvido pelos alunos Clarissa Lopes, Denys Sales, José Vitor, Pedro Abner e Rafael Padilha para a disciplina de Infraestrutura de Software</p>
            </div>
        </footer>
    </main>

    <script src="script.js"></script>
</body>
</html>
